<!DOCTYPE HTML>
<html lang="en" >
    
    <head>
        
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <title>Documentación API Router (Express) | Links al deploy</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 2.5.2">
        
        
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">
        
    <link rel="stylesheet" href="../../gitbook/style.css">
    
        
        <link rel="stylesheet" href="../../gitbook/plugins/gitbook-plugin-highlight/website.css">
        
    
        
        <link rel="stylesheet" href="../../gitbook/plugins/gitbook-plugin-search/search.css">
        
    
        
        <link rel="stylesheet" href="../../gitbook/plugins/gitbook-plugin-fontsettings/website.css">
        
    
    

        
    
    
    
    <link rel="prev" href="../../docs/UsingMDW/index.html" />
    

        
    </head>
    <body>
        
        
    <div class="book" data-level="4" data-chapter-title="Documentación API Router (Express)" data-filepath="docs/RAPID/README.md" data-basepath="../.." data-revision="Mon Mar 06 2017 21:32:17 GMT+0000 (WET)">
    

<div class="book-summary">
    <nav role="navigation">
        <ul class="summary">
            
            
            
            

            

            
    
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../../index.html">
                
                        <i class="fa fa-check"></i>
                        
                        Introduction
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="1" data-path="docs/BasicR/index.html">
            
                
                    <a href="../../docs/BasicR/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                        Direccionamiento Básico
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="2" data-path="docs/RoutingG/index.html">
            
                
                    <a href="../../docs/RoutingG/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>2.</b>
                        
                        Guía de Direccionamiento
                    </a>
            
            
        </li>
    
        <li class="chapter " data-level="3" data-path="docs/UsingMDW/index.html">
            
                
                    <a href="../../docs/UsingMDW/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>3.</b>
                        
                        Middlewares
                    </a>
            
            
        </li>
    
        <li class="chapter active" data-level="4" data-path="docs/RAPID/index.html">
            
                
                    <a href="../../docs/RAPID/index.html">
                
                        <i class="fa fa-check"></i>
                        
                            <b>4.</b>
                        
                        Documentación API Router (Express)
                    </a>
            
            
        </li>
    


            
            <li class="divider"></li>
            <li>
                <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
                    Published with GitBook
                </a>
            </li>
            
        </ul>
    </nav>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header" role="navigation">
    <!-- Actions Left -->
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../" >Links al deploy</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1" role="main">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-">
                    
                        <h2 id="router">Router</h2>
<p>Un objeto router es una instancia aislada de middleware y rutas. Usted puede pensar en &#xE9;l como un &quot;mini-aplicaci&#xF3;n,&quot; s&#xF3;lo capaz de realizar funciones de middleware y de instalaci&#xF3;n. Cada aplicaci&#xF3;n Express tiene una aplicaci&#xF3;n router incorporada.</p>
<p>Un router se comporta como middleware en s&#xED;, por lo que se puede utilizar como argumento para app.use () o como el argumento del otro router () el uso del m&#xE9;todo.</p>
<p>Una vez que haya creado un objeto router, se puede a&#xF1;adir middleware y el m&#xE9;todo HTTP v&#xED;as (por ejemplo get, put, post, etc.) para que al igual que una aplicaci&#xF3;n. Por ejemplo:</p>
<pre><code class="lang-Bash">router.use(<span class="hljs-keyword">function</span>(req, res, next) {
  next();
});
router.get(<span class="hljs-string">&apos;/events&apos;</span>, <span class="hljs-keyword">function</span>(req, res, next) {
});
</code></pre>
<p>A continuaci&#xF3;n, puede utilizar un router para una direcci&#xF3;n URL determinada ra&#xED;z de esta manera la separaci&#xF3;n de sus rutas en archivos o incluso mini-aplicaciones.</p>
<pre><code class="lang-Bash">app.use(<span class="hljs-string">&apos;/calendar&apos;</span>, router);
</code></pre>
<h3 id="m&#xE9;todos">M&#xE9;todos</h3>
<p>router.all (camino, [de devoluci&#xF3;n de llamada, ...] devoluci&#xF3;n de llamada)
Este m&#xE9;todo es igual que los router.METHOD()m&#xE9;todos, excepto que coincide con todos los m&#xE9;todos HTTP (verbos).</p>
<p>Este m&#xE9;todo es muy &#xFA;til para el mapeo l&#xF3;gico &quot;global&quot; para los prefijos de ruta espec&#xED;ficas o partidos arbitrarias. Por ejemplo, si se coloca la siguiente ruta en la parte superior de todas las otras definiciones de ruta, que requerir&#xED;a que todas las rutas desde ese punto en requerir&#xED;an autenticaci&#xF3;n y cargar autom&#xE1;ticamente un usuario. Tenga en cuenta que estas devoluciones de llamada no tienen que actuar como puntos finales; loadUser puede realizar una tarea, a continuaci&#xF3;n, llamar next()a continuar b&#xFA;squeda de rutas posteriores.</p>
<pre><code class="lang-Bash">router.all(<span class="hljs-string">&apos;*&apos;</span>, requireAuthentication, loadUser);
</code></pre>
<p>O el equivalente:</p>
<pre><code class="lang-Bash">router.all(<span class="hljs-string">&apos;*&apos;</span>, requireAuthentication)
router.all(<span class="hljs-string">&apos;*&apos;</span>, loadUser);
</code></pre>
<p>Otro ejemplo de esto es la lista blanca funcionalidad &quot;global&quot;. Aqu&#xED; el ejemplo es mucho m&#xE1;s que antes, pero s&#xF3;lo restringe caminos con el prefijo &quot;/ api&quot;:</p>
<pre><code class="lang-Bash">router.all(<span class="hljs-string">&apos;/api/*&apos;</span>, requireAuthentication);
</code></pre>
<p>router.METHOD (camino, [de devoluci&#xF3;n de llamada, ...] devoluci&#xF3;n de llamada)</p>
<p>Los router.METHOD()m&#xE9;todos proporcionan la funcionalidad de enrutamiento en Express, donde m&#xE9;todo es uno de los m&#xE9;todos HTTP, como GET, PUT, POST, y as&#xED; sucesivamente, en min&#xFA;sculas. Por lo tanto, los m&#xE9;todos actuales son router.get(), router.post(), router.put(), y as&#xED; sucesivamente.
La router.get()funci&#xF3;n se llama autom&#xE1;ticamente para el HTTP HEADm&#xE9;todo adem&#xE1;s del GETm&#xE9;todo si router.head()no fue llamado por el camino antes router.get().
Puede proporcionar m&#xFA;ltiples servicios repetidos, y todos son tratados por igual, y se comportan igual que el middleware, excepto que estas devoluciones de llamada pueden invocar next(&apos;route&apos;) para eludir la devoluci&#xF3;n de llamada ruta restante (s). Puede utilizar este mecanismo para llevar a cabo precondiciones en una ruta a continuaci&#xF3;n, pasar el control a rutas posteriores, cuando no hay ninguna raz&#xF3;n para continuar con la ruta buscada.</p>
<p>El siguiente fragmento ilustra posible la definici&#xF3;n de la ruta m&#xE1;s sencilla. Expresa traduce las cadenas de ruta a las expresiones regulares, que se utiliza internamente para que coincida con las peticiones entrantes. Las cadenas de consulta se no cuenta a la hora de realizar estos partidos, por ejemplo &quot;GET /&quot; se corresponder&#xED;a con la siguiente ruta, como ser&#xED;a &quot;GET /? Name = tobi&quot;.</p>
<pre><code class="lang-Bash">router.get(<span class="hljs-string">&apos;/&apos;</span>, <span class="hljs-keyword">function</span>(req, res){
  res.send(<span class="hljs-string">&apos;hello world&apos;</span>);
});
</code></pre>
<p>Tambi&#xE9;n puede utilizar expresiones &#xFA;tiles-regulares si tiene limitaciones muy espec&#xED;ficas, por ejemplo, lo siguiente ser&#xED;a igualar &quot;GET / cometa / 71dbb9c&quot;, as&#xED; como &quot;GET /commits/71dbb9c..4c084f9&quot;.</p>
<pre><code class="lang-Bash">router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, <span class="hljs-keyword">function</span>(req, res){
  var from = req.params[<span class="hljs-number">0</span>];
  var to = req.params[<span class="hljs-number">1</span>] || <span class="hljs-string">&apos;HEAD&apos;</span>;
  res.send(<span class="hljs-string">&apos;commit range &apos;</span> + from + <span class="hljs-string">&apos;..&apos;</span> + to);
});
</code></pre>
<p>router.param (nombre, devoluci&#xF3;n de llamada)</p>
<p>Agrega devoluci&#xF3;n de llamada activa a par&#xE1;metros de la ruta, donde namees el nombre del par&#xE1;metro y callbackes la funci&#xF3;n de devoluci&#xF3;n de llamada. Aunque namet&#xE9;cnicamente es opcional, utilizando este m&#xE9;todo sin ella est&#xE1; en desuso empezando con expreso v4.11.0 (v&#xE9;ase m&#xE1;s adelante).</p>
<p>Los par&#xE1;metros de la funci&#xF3;n de devoluci&#xF3;n de llamada son:</p>
<p>req, La solicitud de objeto.
res, El objeto respuesta.
next, Lo que indica la siguiente funci&#xF3;n de middleware.
El valor del namepar&#xE1;metro.
El nombre del par&#xE1;metro.
A diferencia app.param(), router.param()no acepta una gran variedad de par&#xE1;metros de la ruta.
Por ejemplo, cuando :userest&#xE1; presente en una ruta de ruta, es posible asignar la l&#xF3;gica de carga del usuario para proporcionar autom&#xE1;ticamente req.usera la ruta, o realizar validaciones sobre la introducci&#xF3;n de par&#xE1;metros.</p>
<pre><code class="lang-Bash">router.param(<span class="hljs-string">&apos;user&apos;</span>, <span class="hljs-keyword">function</span>(req, res, next, id) {

  User.find(id, <span class="hljs-keyword">function</span>(err, user) {
    <span class="hljs-keyword">if</span> (err) {
      next(err);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (user) {
      req.user = user;
      next();
    } <span class="hljs-keyword">else</span> {
      next(new Error(<span class="hljs-string">&apos;failed to load user&apos;</span>));
    }
  });
});
</code></pre>
<p>Param funciones de devoluci&#xF3;n de llamada son locales al router en el que est&#xE1;n definidas. Ellos no son heredados por aplicaciones o routers montados. Por lo tanto, las devoluciones de llamada param definidos en routerse activar&#xE1;n solamente por par&#xE1;metros de ruta definidos en routerlas rutas.</p>
<p>Una devoluci&#xF3;n de llamada param ser&#xE1; llamado s&#xF3;lo una vez en un ciclo de petici&#xF3;n-respuesta, incluso si el par&#xE1;metro se corresponde en m&#xFA;ltiples rutas, como se muestra en los siguientes ejemplos.</p>
<pre><code class="lang-Bash">
router.param(<span class="hljs-string">&apos;id&apos;</span>, <span class="hljs-keyword">function</span> (req, res, next, id) {
  console.log(<span class="hljs-string">&apos;CALLED ONLY ONCE&apos;</span>);
  next();
});

router.get(<span class="hljs-string">&apos;/user/:id&apos;</span>, <span class="hljs-keyword">function</span> (req, res, next) {
  console.log(<span class="hljs-string">&apos;although this matches&apos;</span>);
  next();
});

router.get(<span class="hljs-string">&apos;/user/:id&apos;</span>, <span class="hljs-keyword">function</span> (req, res) {
  console.log(<span class="hljs-string">&apos;and this matches too&apos;</span>);
  res.end();
});
</code></pre>
<p>En GET /user/42, se imprime la siguiente:</p>
<pre><code class="lang-Bash">CALLED ONLY ONCE
although this matches
and this matches too
</code></pre>
<p>El comportamiento del router.param(name, callback)m&#xE9;todo se puede alterar por completo al pasar s&#xF3;lo una funci&#xF3;n a router.param(). Esta funci&#xF3;n es una implementaci&#xF3;n personalizada de c&#xF3;mo router.param(name, callback)debe comportarse - acepta dos par&#xE1;metros y debe devolver un middleware.</p>
<p>El primer par&#xE1;metro de esta funci&#xF3;n es el nombre del par&#xE1;metro de URL que debe ser capturado, el segundo par&#xE1;metro puede ser cualquier objeto JavaScript que pudieran utilizarse para el retorno de la aplicaci&#xF3;n de middleware.</p>
<p>El middleware devuelto por la funci&#xF3;n decide el comportamiento de lo que sucede cuando se captura un par&#xE1;metro de URL.</p>
<p>En este ejemplo, la router.param(name, callback)firma se modifica para router.param(name, accessId). En lugar de aceptar un nombre y una devoluci&#xF3;n de llamada, router.param()ahora aceptar&#xE1; un nombre y un n&#xFA;mero.</p>
<pre><code class="lang-Bash">
var express = require(<span class="hljs-string">&apos;express&apos;</span>);
var app = express();
var router = express.Router();

router.param(<span class="hljs-keyword">function</span>(param, option) {
  <span class="hljs-built_in">return</span> <span class="hljs-keyword">function</span> (req, res, next, val) {
    <span class="hljs-keyword">if</span> (val == option) {
      next();
    }
    <span class="hljs-keyword">else</span> {
      res.sendStatus(<span class="hljs-number">403</span>);
    }
  }
});

router.param(<span class="hljs-string">&apos;id&apos;</span>, <span class="hljs-number">1337</span>);

router.get(<span class="hljs-string">&apos;/user/:id&apos;</span>, <span class="hljs-keyword">function</span> (req, res) {
  res.send(<span class="hljs-string">&apos;OK&apos;</span>);
});

app.use(router);

app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-title">function</span></span> () {
  console.log(<span class="hljs-string">&apos;Ready&apos;</span>);
});
</code></pre>
<p>En este ejemplo, la router.param(name, callback)firma sigue siendo el mismo, pero en vez de una devoluci&#xF3;n de llamada de middleware, una funci&#xF3;n de verificaci&#xF3;n de tipos de datos personalizados se ha definido para validar el tipo de datos de la identificaci&#xF3;n del usuario.</p>
<pre><code class="lang-Bash">router.param(<span class="hljs-keyword">function</span>(param, validator) {
  <span class="hljs-built_in">return</span> <span class="hljs-keyword">function</span> (req, res, next, val) {
    <span class="hljs-keyword">if</span> (validator(val)) {
      next();
    }
    <span class="hljs-keyword">else</span> {
      res.sendStatus(<span class="hljs-number">403</span>);
    }
  }
});

router.param(<span class="hljs-string">&apos;id&apos;</span>, <span class="hljs-keyword">function</span> (candidate) {
  <span class="hljs-built_in">return</span> !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);
});
router.route (ruta)
</code></pre>
<p>Devuelve una instancia de una sola ruta que luego se puede utilizar para manejar los verbos HTTP con el middleware opcional. Utilizar router.route()para evitar la nomenclatura ruta duplicada y por lo tanto los errores de escritura.</p>
<p>Bas&#xE1;ndose en el router.param()ejemplo anterior, el c&#xF3;digo siguiente muestra c&#xF3;mo utilizar  router.route()para especificar varios manipuladores m&#xE9;todo HTTP.</p>
<pre><code class="lang-Bash">var router = express.Router();

router.param(<span class="hljs-string">&apos;user_id&apos;</span>, <span class="hljs-keyword">function</span>(req, res, next, id) {
  req.user = {
    id: id,
    name: <span class="hljs-string">&apos;TJ&apos;</span>
  };
  next();
});

router.route(<span class="hljs-string">&apos;/users/:user_id&apos;</span>)
.all(<span class="hljs-keyword">function</span>(req, res, next) {
  next();
})
.get(<span class="hljs-keyword">function</span>(req, res, next) {
  res.json(req.user);
})
.put(<span class="hljs-keyword">function</span>(req, res, next) {
  req.user.name = req.params.name;
  res.json(req.user);
})
.post(<span class="hljs-keyword">function</span>(req, res, next) {
  next(new Error(<span class="hljs-string">&apos;not implemented&apos;</span>));
})
.delete(<span class="hljs-keyword">function</span>(req, res, next) {
  next(new Error(<span class="hljs-string">&apos;not implemented&apos;</span>));
});
</code></pre>
<p>Este enfoque vuelve a utilizar la &#xFA;nica /users/:user_idv&#xED;a de acceso y a&#xF1;ade manejadores para diversos m&#xE9;todos HTTP.</p>
<p>router.use ([ruta], [funci&#xF3;n, ...] funci&#xF3;n)
Utiliza la funci&#xF3;n especificada middleware o funciones, con la ruta de montaje opcional path, que por defecto es &quot;/&quot;.</p>
<p>Este m&#xE9;todo es similar a app.use () . Un ejemplo sencillo y el uso caso se describe a continuaci&#xF3;n. Ver app.use () para obtener m&#xE1;s informaci&#xF3;n.</p>
<p>Middleware es como un tubo de fontaner&#xED;a: peticiones comienzan a partir de la primera funci&#xF3;n de middleware definido y se abren camino a la transformaci&#xF3;n pila de middleware &quot;hacia abajo&quot; para cada ruta que coinciden.</p>
<pre><code>var express = require(&apos;express&apos;);
var app = express();
var router = express.Router();

router.use(function(req, res, next) {
  console.log(&apos;%s %s %s&apos;, req.method, req.url, req.path);
  next();
});

router.use(&apos;/bar&apos;, function(req, res, next) {
  next();
});

router.use(function(req, res, next) {
  res.send(&apos;Hello World&apos;);
});

app.use(&apos;/foo&apos;, router);

app.listen(3000);
</code></pre><p>La ruta de &quot;montaje&quot; se desnud&#xF3; y es no visible para la funci&#xF3;n de middleware. El principal efecto de esta caracter&#xED;stica es que una funci&#xF3;n montada middleware puede funcionar sin cambios en el c&#xF3;digo, independientemente de su ruta &quot;prefijo&quot;.</p>
<p>El orden en el que se define con el middleware router.use()es muy importante. Se invocan de forma secuencial, por tanto, el orden de precedencia define middleware. Por ejemplo, por lo general un registrador es el primer middleware que utilizar&#xED;a, por lo que cada solicitud se registra.</p>
<pre><code class="lang-Bash">var logger = require(<span class="hljs-string">&apos;morgan&apos;</span>);

router.use(logger());
router.use(express.static(__dirname + <span class="hljs-string">&apos;/public&apos;</span>));
router.use(<span class="hljs-keyword">function</span>(req, res){
  res.send(<span class="hljs-string">&apos;Hello&apos;</span>);
});
</code></pre>
<p>Ahora suponga que desea ignorar las solicitudes de registro de archivos est&#xE1;ticos, pero para seguir las rutas de registro y middleware definidos despu&#xE9;s logger(). S&#xF3;lo tendr&#xED;a que mover la llamada a express.static()la parte superior, antes de a&#xF1;adir el middleware registrador:</p>
<pre><code>router.use(express.static(__dirname + &apos;/public&apos;));
router.use(logger());
router.use(function(req, res){
  res.send(&apos;Hello&apos;);
});
</code></pre><p>Otro ejemplo est&#xE1; sirviendo archivos de varios directorios, dando prioridad a &quot;./public&quot; sobre los dem&#xE1;s:</p>
<pre><code>app.use(express.static(__dirname + &apos;/public&apos;));
app.use(express.static(__dirname + &apos;/files&apos;));
app.use(express.static(__dirname + &apos;/uploads&apos;));
</code></pre><p>El router.use()m&#xE9;todo tambi&#xE9;n es compatible con los par&#xE1;metros nombrado para que sus puntos de montaje para otros routers pueden beneficiarse de precarga utilizando los par&#xE1;metros con nombre.</p>
<pre><code class="lang-Bash">var authRouter = express.Router();
var openRouter = express.Router();

authRouter.use(require(<span class="hljs-string">&apos;./authenticate&apos;</span>).basic(usersdb));

authRouter.get(<span class="hljs-string">&apos;/:user_id/edit&apos;</span>, <span class="hljs-keyword">function</span>(req, res, next) { 
});

openRouter.get(<span class="hljs-string">&apos;/&apos;</span>, <span class="hljs-keyword">function</span>(req, res, next) { 
})

openRouter.get(<span class="hljs-string">&apos;/:user_id&apos;</span>, <span class="hljs-keyword">function</span>(req, res, next) { 
})

app.use(<span class="hljs-string">&apos;/users&apos;</span>, authRouter);
app.use(<span class="hljs-string">&apos;/users&apos;</span>, openRouter);
</code></pre>
<p>A pesar de que el middleware de autenticaci&#xF3;n se a&#xF1;adi&#xF3; a trav&#xE9;s de la authRouterque se ejecutar&#xE1; en las rutas definidas por el openRoutertambi&#xE9;n puesto que ambos routers se montaron sobre /users. Para evitar este comportamiento, utilice diferentes rutas para cada router.</p>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../../docs/UsingMDW/index.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Middlewares"><i class="fa fa-angle-left"></i></a>
        
        
    </div>
</div>

        
<script src="../../gitbook/app.js"></script>

    
    <script src="../../gitbook/plugins/gitbook-plugin-search/lunr.min.js"></script>
    

    
    <script src="../../gitbook/plugins/gitbook-plugin-search/search.js"></script>
    

    
    <script src="../../gitbook/plugins/gitbook-plugin-sharing/buttons.js"></script>
    

    
    <script src="../../gitbook/plugins/gitbook-plugin-fontsettings/buttons.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"highlight":{},"search":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
